数据高级操作：
  新增数据：
    基本语法：
      insert into 表名[(字段列表)] values(值列表);
    主键冲突：
      在数据插入的时候，假设主键对应的值已经存在，插入就会失败！
      
      当主键存在冲突的时候，可以选择性进行处理：更新和替换
      
      更新操作：
        insert into 表名[(字段列表)] values(值列表) on duplicate key update 字段 = 新值;
        -- 创建带有主键的表
        create table my_class(
          number varchar(10) primary key,
          room varchar(20),
          )charset utf8;
        -- 插入一条数据
        insert into my_class('0001', 'B205');
        
        -- 插入一条主键冲突的数据
        insert into my_class('0001', 'B205') on duplicate key update room = 'B205'
        
      替换操作：
        replace into 表名[(字段列表)] values(值列表);    -- 当有主键冲突的时候直接替换冲突行，没有冲突的时候正常插入
        
        
    蠕虫复制：
      蠕虫复制：从已有的数据中获取数据，然后又将数据进行新增操作，数据成倍增加
      
      表创建的高级操作：从已有表创建新表（复制表结构）：
      create table 表名 like 数据库.表名；
      -- 复制创建表
      create table my_copy like my_class; -- 只复制表结构，不复制数据
      
      蠕虫复制: 先查出数据，然后将查出的数据新增一遍
      insert into 目标表名[(字段列表)] select 字段列表/* from 源表名;
      
      -- 蠕虫复制my_class中的数据
      insert into my_copy select * from my_class;
      
    蠕虫复制的意义：
      1. 从已有表中拷贝数据到新表中
      2. 可以迅速的让表中的数据膨胀到一定的数量级，测试表的压力以及效率
      
      
  高级更新数据：
    基本语法：
      update 表名 set 字段 = 值 [where 条件];
    高级更新语法：
      update 表名 set 字段 = 值 [where 条件] [limit 更新数量];
    -- 更新部分数据
    update my_copy set name = 'c' where name = 'a' limit 3;   -- 更新三条数据
    
    
  高级删除数据：
    基本语法：
      delete from 表名 [where 条件]；
    高级删除语法：
      delete from 表名 [where 条件] [limit 删除数量]；
      delete from my_copy where name = 'b' limit 3; -- 删除三条数据
      
    如果表中存在自增长，删除后自增长不会还原，因为数据的删除不会改变表结构，要解决这个问题只能删除表然后创建表，使用如下语法：
    -- 清空表，重置自增长
    truncate 表名;    -- 该语句会清楚表中所有数据
    
  高级查询语句：
    基本语法：
      select (字段列表)/* from 表名 [where 条件];
    完整语法：
      select [select选项] 字段列表/* from 数据源 [wjere 条件子句] [group by 子句] [having 子句] [order by 子句] [limit 子句];
      
      select选项：select对查出来的结果的处理方式
        all: 默认的，保留所有结果
        distinct: 去重，查出来的结果，去除重复值（所有字段都相同）
        -- select选项
        select distinct * from my_copy;   -- 去除重复值
        
      字段别名
        当数据进行查询的时候，有时候（多表查询的时候会出现同名字段）需要对字段进行重命名--别名
        语法：字段名 [as] 别名;
        
        -- 字段别名查询
        select
        id,
        number as 学号,
        name as 姓名,
        sex 性别 from my_students;    -- as可以省略
        
      数据源：
        数据的来源，关系型数据库的数据来源都是数据表，本质上只要保证数据类似二维表，最终都可以作为数据源
        
        数据源分为：单表数据源，多表数据源，查询语句
        
          单表数据源：
            select * from 表名;
          多表数据源：
            select * from 表名1,表名2,...表名n;   -- 查询结果是 多张表的笛卡尔积（交叉连接）,浪费资源，效率很低，应该尽量避免
          查询语句(子查询):
            select * from (select 语句) as 别名;
            select * from (selet * from my_student) as s;
            
          where子句:
            用来判断数据，筛选子句，where子句的返回结果 0或者1 ，0代表false，1代表true
            判断条件：
              比较运算符： >,<,>=,<=,!=,=,like,between,and,in,not in
              逻辑运算符：&&(and)，||(or)， ！(not)
              
              where是唯一一个直接从磁盘获取数据的时候就开始判断，读入到内存的数据都是有效数据
              
              -- 创建人员信息表：
              create table my_personinfo(
                id int auto_increm primary key,
                name varchar(20) not null,
                gender varchar(2) not null,
                height tinyint not null,
                age tinyint not null
                )charset utf8;
                
              -- 查询学生id为1/3/5的人员
              select * from my_personinfo where id in(1,3,5);
              select * from my_personinfo where id = 1 || id = 3 || id = 5;
              
              -- 查询身高在180-190的人员
              select * from my_personinfo where height >= 180 and height <= 190;
              select * from my_personinfo where height between 180 and 190;   --  between本身是闭区间，左边的值必须小于右边的值
              
          group by 子句:
            根据某个字段分组
            select * from my_personinfo group by gender
              
              
              
              
              
              
              
              
              
              
              
              
              
        
    
    
    
    
    
    
      
      
      
      
      
      
